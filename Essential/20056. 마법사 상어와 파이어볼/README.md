## 문제 이해

* N×N 격자에서 파이어볼들이 K번 이동·합체·분리된다.
* 각 파이어볼: 위치 `(r,c)`, 질량 `m`, 속력 `s`, 방향 `d(0~7)`.
* 한 칸에 2개 이상 모이면 **하나로 합친 뒤** 4개로 **분리**
  * 새 질량 = ⌊(합 질량)/5⌋ (0이면 소멸)
  * 새 속력 = ⌊(합 속력)/개수⌋
  * 새 방향: 모두 짝/홀만 있었으면 `{0,2,4,6}`, 섞여 있으면 `{1,3,5,7}`

## 구현 흐름
1. 입력  
  * `fireBall` 리스트에 모든 파이어볼 저장
  * `map[r][c]`에는 해당 칸에 존재하는 파이어볼 저장

2. **K번 반복**
  * 이동 `move()`
    * 모든 파이어볼을 방향·속력대로 이동
    * 이동 후 `map`에 삽입
  * 합체 후 4분리 `divide(int r, int c)`
    * `map[i][j] >= 2`인 칸만 `divide(i, j)` 수행
    * `map` 초기화
3. 출력
  * `calcSum()`로 남은 모든 파이어볼의 질량 합 출력

## 함수별 상세 기능
### `move()`: 파이어볼 이동
방향 d로 s칸 이동. 격자의 범위, 음수를 고려하여 `(r + dr[d] * (s % n) + n) % n`로 처리
  * `s % n`: `s`의 크기가 큰 경우를 고려하여 이동거리를 축소

### `divide(int r, int c)`: 합체 후 4분리
* `map`의 해당 칸을 한 번 순회하며, 질량 합 (`m`), 속력 합 (`s`), 파이어볼 개수 합 (`cnt`), 짝/홀 여부 (`even`/`odd`) 집계
* 합체된 파이어볼 제거: `fireBall.remove(cur)`
* 집계 후 `map` 초기화
* 새 질량, 속력, 방향 구하기
  * 새 질량: `m /= 5` (0이면 소멸)
  * 새 속력: `s /= cnt`
  * 짝/홀 섞임 여부`(odd && even)`에 따라 방향 집합을 `{0,2,4,6}` 또는 `{1,3,5,7}`으로 4개 생성해 `fireBall`에 추가

### `calcSum()`: 남은 질량 합산
* `fireBall` 리스트 순회하며 `m`을 누적해서 리턴

## 성능 개선
### 이전 코드 (카운트 저장 `int[][] map`)
`divide(r, c)`에서 그 칸의 파이어볼을 찾으려 전체 `fireBall` 리스트를 탐색

``` java
for (int i = 0; i < fireBall.size(); i++) {
			FireBall cur = fireBall.get(i);
			if (cur.r == r && cur.c == c) {
        // 새 질량, 속력, 방향 집계
      }
}
```

### 개선 후 코드 (객체 저장 `ArrayList<FireBall>[][] map`)
``` java
map[f.r][f.c].add(f);
```

### 실행시간 감소
이전 코드에서 자료구조는 단순했지만, 파이어볼이 2개 이상인 칸이 많아질수록 탐색 시간이 급격히 늘어났다.  
이동 단계에서 파이어볼을 바로 해당 칸(map[r][c])에 저장하도록 변경한 후에는,  
`divide()` 수행 시 탐색 과정 없이 해당 칸의 리스트만 바로 접근할 수 있게 되어 실행 시간이 크게 줄었다.

![이전 실행 시간](before.png)  
![이후 실행 시간](after.png)
