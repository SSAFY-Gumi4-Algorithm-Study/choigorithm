## 문제 이해

* `N×M` 체육관에 빈 칸(`.`)과 벽(`X`)이 있다.
* 한 번 이동할 때, **상·하·좌·우 중 한 방향으로 1칸 이상 `k`칸 이하**를 이동할 수 있다.
* 시작점에서 도착점까지 이동하는 최소 시간을 구한다.


## 문제 풀이
BFS를 이용하여 각 칸에 도달하는 **최소 시간**을 기록한다.  
상하좌우(`dr`, `dc`) 네 방향에 대해 `1..k`칸 이동하는 경우를 탐색한다.

### 상태 정의

* `map[r][c] = -1`: **미방문**, `-2`: **벽**으로 초기화
* BFS 탐색하면서 **해당 칸에 도달한 최소 시간** 저장

### 탐색 조건

1. **미방문**: `map[nr][nc] == -1`

   지금이 **처음 도달**이므로 `map[nr][nc] = map[cur.r][cur.c] + 1`로 갱신하고 큐에 넣는다.

2. **이미 더 빠른 시간에 도달** `map[nr][nc] < map[cur.r][cur.c] + 1`  

   이 칸에는 현재 시간보다 빠르게 이미 왔으므로, **그 뒤 칸들**도 이 경로보다 이득이 될 수 없다.  
   → **이 방향 탐색을 중단**한다. (`break`)

3. **같은 시간으로 이미 방문** `map[nr][nc] == map[cur.r][cur.c] + 1`

   * 다른 경로로 같은 이동 시간에 이미 큐에 들어갔던 칸.
   * 다시 큐에 넣을 필요는 없다.
   * 하지만 **그 뒤 칸**은 아직 미방문일 수 있으므로 **계속 확인**해야 한다.  
   → 이번 칸은 패스하고 같은 방향의 다음 칸으로 진행 (`continue`)

<br>

```java
if (map[nr][nc] == -1) { // 미방문
    q.offer(new Point(nr, nc));
    map[nr][nc] = map[cur.r][cur.c] + 1;
} else if (map[nr][nc] < map[cur.r][cur.c] + 1) { // 이미 현재 시간보다 빨리 도착.
    break;
    } 
// map[nr][nc] == t+1 이면 그냥 다음 step 계속
```

### 주의 사항
**범위를 벗어났거나 벽(#)을 만났을 때는 continue가 아니라 break**를 써야 한다.

: 같은 방향으로 칸을 늘려가는 과정에서 앞이 막히면 그 뒤 칸들도 전부 갈 수 없기 때문.  
→ 이 방향 탐색 자체를 중단해야 한다.
