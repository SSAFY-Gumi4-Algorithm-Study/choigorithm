## 문제 이해

* N개의 문제마다 **데드라인**과 받을 수 있는 **컵라면 수**가 주어진다.
* 한 문제당 푸는 데 단위 시간 1이 걸린다.
* 받을 수 있는 **컵라면의 총합의 최댓값**을 출력한다.

## 풀이 아이디어 (그리디)

1. 문제 정보를 배열에 담아서 정렬한다.
   - **데드라인이 빠른 문제부터**
   - 같은 데드라인이라면 **보상이 큰 문제부터**

2. 배열의 요소를 탐색하면서 PQ에 담는다.

- **PQ**
  * **현재까지 선택한 문제들의 컵라면 수**를 저장
  * PQ의 크기: 문제를 푼 수
  * PQ의 원소: 문제를 풀고 얻은 컵라면 수

- **로직**
  * 현재 문제가 데드라인까지 시간이 남았다면 (지금까지 푼 문제 수 `<` 현재 문제의 데드라인)  
  → 추가
  * 더 큰 보상으로 교체할 여지가 있다면 (지금까지 푼 문제수 `=` 현재 문제의 데드라인)  
  → 이미 푼 문제의 보상과 비교해서, 현재 보상이 더 크면 교체한다.

## 핵심 로직

```java
for (Problem cur : problems) {
    if (pq.size() < cur.deadline) pq.add(cur.reward);
    else if (pq.peek() < cur.reward) {
        pq.poll();
        pq.add(cur.reward);
    }
}
```

마지막에 PQ에 남은 값(선택된 문제들)의 합을 모두 더하면 정답이다.
