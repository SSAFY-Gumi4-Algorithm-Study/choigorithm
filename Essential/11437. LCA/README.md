## 풀이 흐름
**DFS로 `parent`/`depth` 저장 → 깊이 맞추기 → 함께 올라가면서 같아지는 지점 반환**

1. **트리 DFS로 각 노드의 부모, 깊이 저장하기**
* 루트부터 자식으로 내려가면서 `parent`, `depth` 배열에 저장  
* 루트(1)는 부모를 자기 자신(1)으로, 깊이는 0으로 (`dfs(1, 1, 0)`)

2. **LCA 구하기**
* **깊이 맞추기**
  * 더 깊은 쪽을 부모로 올려서 `depth[a] == depth[b]`로 만듦.
* **공통 조상 찾기**
  * `a == b`가 될 때까지 둘 다 `parent`로 올라감.
  * 같아지면 그 노드가 LCA.

## 유의할 점 (예외)
**a, b가 같은 노드**이거나, **한쪽이 다른 쪽의 조상**일 수 있다.  
이때 **LCA는 그 노드 자신**이어야 한다.  

**잘못된 코드**
```java
while (parent[a] != parent[b]) {
    a = parent[a];
    b = parent[b];
}
return parent[a]; // 부모를 반환
```
공통 부모를 찾는 것이라서 a, b의 부모가 같을 때까지 올라가고 같으면 부모를 반환했다.  
이럴 경우, 깊이를 맞춘 후에 두 노드가 같을 때 문제가 발생한다.  
두 노드의 부모를 반환 → 한 단계 더 올라간 값을 반환해서 오답이 출력된다.  

**수정한 코드**
```java
while (a != b) {
    a = parent[a];
    b = parent[b];
}

return a;
```
